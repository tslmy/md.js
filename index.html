<!DOCTYPE html>
<html lang="en">

<head>
    <title>Molecular Dynamics</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
    <style>
    html,
    body {
        padding: 0;
        margin: 0;
    }
    .mapscale {
        position: fixed;
        left: 30px;
        height: 5px;
        width: 0px;
        border-top:0px solid #000000;
        border-right:1px solid #000000;
        border-bottom:1px solid #000000;
        border-left:1px solid #000000;
        opacity: .5;
        font:11px "Lucida Grande",sans-serif;
        line-height:30px;
    }
    .mapscale#force {
        bottom: 50px;
    }
    .mapscale#velocity {
        bottom: 80px;
    }
    </style>
</head>
<<<<<<< HEAD
<body>
    <script src="//fast.eager.io/YEbsDk5Uy-.js"></script><!--for loading indicator-->
    <script src=
    "https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js">
    </script> 
    <script src=
    "https://cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js">
    </script> 
    <script src=
    "https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js">
    </script> 
    <script src="https://cdn.jsdelivr.net/lodash/4.13.1/lodash.min.js">
    </script> 
    <!--script src="//cdn.rawgit.com/mrdoob/three.js/master/examples/js/Detector.js"></script-->
     
    <script src=
    "https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js">
    </script> 
    <script src=
    "https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/effects/StereoEffect.js">
    </script> 
    <script src=
    "https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/DeviceOrientationControls.js">
    </script> 
    <script>
    //===============options and settings:
    var particleCount = 20;
    var maxTrajectoryLength = 500;
    var spaceBoundaryX = 5;
    var spaceBoundaryY = 0.1;
    var spaceBoundaryZ = 5;
    var dt = 0.01;
    var availableCharges = [-3, -2, -1, 0, 1, 2, 3];
    var d_min = 0.02;
    var sunMass = 500;
    //toggles for functions:
    var if_apply_LJpotential = true;
    var if_apply_gravitation = true;
    var if_apply_coulombForce = true;
    var if_ReferenceFrame_movesWithSun = true;
    var if_makeSun = true;
    var if_showUniverseBoundary = true;
    var if_showTrajectory = true;
    var if_useFog = false;
    //physical constants -- be the god!
    var EPSILON = 1;
    var DELTA = 0.02;
    var G = 0.08;
    var K = 0.1;
    var max_arrow_length = 2;
    //====================================
    //global variables
    var camera, scene, renderer;
    var effect, controls;
    var element, container;
    var if_mobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ;
    var geometry, material, mesh, particleMaterial, trajectoryMaterial;
    var particleColors = [];
    var particlePositions = [];
    var particleForces = [];
    var particleVelocities = [];
    var particleMasses = [];
    var particleCharges = [];
    var arrowVelocities = [];
    var arrowForces = [];
    var trajectoryGeometries = [];
    var trajectoryLines = [];
    var totalMass = 0;
    var time = 0;
    var lastSnapshotTime = 0;
    var snapshotDuration = 2*dt;
    //local storage functions:
    function save(name, obj) {
    	localStorage.setItem(name, JSON.stringify(obj));
    };
    function saveState() {
		save('particleColors', 		particleColors);
		save('particlePositions', 	particlePositions);
		save('particleForces', 		particleForces);
		save('particleVelocities', 	particleVelocities);
		save('particleMasses', 		particleMasses);
		save('particleCharges', 	particleCharges);
		save('time', 				time);
		save('lastSnapshotTime', 	lastSnapshotTime);

		console.log('particleColors', 		particleColors);
		console.log('particlePositions', 	particlePositions);
		console.log('particleForces', 		particleForces);
		console.log('particleVelocities', 	particleVelocities);
		console.log('particleMasses', 		particleMasses);
		console.log('particleCharges', 	particleCharges);
		console.log('time', 				time);
		console.log('lastSnapshotTime', 	lastSnapshotTime);
    };
    function clearState() {
		localStorage.removeItem('particleColors');
		localStorage.removeItem('particlePositions');
		localStorage.removeItem('particleForces');
		localStorage.removeItem('particleVelocities');
		localStorage.removeItem('particleMasses');
		localStorage.removeItem('particleCharges');
		localStorage.removeItem('time');
		localStorage.removeItem('lastSnapshotTime');
    };
    //js fixes and helper functions:
    function drawArrow(i, arrowStack, propertyStack) {
      //var vector_from = new THREE.Vector3().copy(from_particle);
      //var vector_direction = new THREE.Vector3().copy(vector);
      if (propertyStack == particleForces) {
        rescalingFactor = 0.0001;
      } else if (propertyStack == particleVelocities) {
        rescalingFactor = 0.02;
      } else {
        console.log('unrecognized propertyStack', propertyStack);
        rescalingFactor = 1;
      }
      var vector = propertyStack[i];
      var vector_from = particlePositions[i];
      //var vector_to = new THREE.Vector3().addVectors(vector_from, vector_direction);
      var vector_length = vector.length() * rescalingFactor;
      if (vector_length > max_arrow_length) {
        vector_length = max_arrow_length
      };
      var vector_direction = new THREE.Vector3().copy(vector).normalize();
      var arrow = arrowStack[i];
      arrow.position.copy(vector_from);
      arrow.setLength(vector_length);
      arrow.setDirection(vector_direction);
    }

    function generateTexture() {
      //credit: http://jsfiddle.net/7yDGy/1/
      // draw a circle in the center of the canvas
      var size = 32;

      // create canvas
      var canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;

      // get context
      var context = canvas.getContext('2d');

      // draw circle
      var centerX = size / 2;
      var centerY = size / 2;
      var radius = size / 2;

      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      context.fillStyle = "#fff";
      context.fill();

      return canvas;
    }

    function drawBox() {
      geometry = new THREE.BoxGeometry(2 * spaceBoundaryX, 2 * spaceBoundaryY, 2 * spaceBoundaryZ);
      material = new THREE.MeshBasicMaterial({
        color: 0xaaaaaa,
        wireframe: true,
        opacity: .8
      });
      //add this object to the scene
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      //add a light to the scene
      /*light = new THREE.AmbientLight( 0x222222 );
                scene.add( light );*/
    }

    function createParticleSystem() {
      function addParticle(colorH, colorS, colorL,
        positionX, positionY, positionZ,
        velocityX, velocityY, velocityZ,
        forceX, forceY, forceZ,
        thisMass, thisCharge) {
        // make colors (http://jsfiddle.net/J7zp4/200/)
        var thisColor = new THREE.Color();
        thisColor.setHSL(colorH, colorS, colorL);
        particleColors.push(thisColor);
        // Create the vertex
        var thisPosition = new THREE.Vector3(positionX, positionY, positionZ);
        particlePositions.push(thisPosition);
        // Add the vertex to the geometry
        particles.vertices.push(thisPosition);
        // make velocity
        var thisVelocity = new THREE.Vector3(velocityX, velocityY, velocityZ);
        particleVelocities.push(thisVelocity);
        // make force
        var thisForce = new THREE.Vector3(forceX, forceY, forceZ);
        particleForces.push(thisForce);
        // mass
        particleMasses.push(thisMass);
        totalMass += thisMass;
        // charge
        particleCharges.push(thisCharge);
        //add two arrows
        var arrow = new THREE.ArrowHelper(new THREE.Vector3(), new THREE.Vector3(), 1, 0x0055aa);
        scene.add(arrow);
        arrowVelocities.push(arrow);
        var arrow = new THREE.ArrowHelper(new THREE.Vector3(), new THREE.Vector3(), 1, 0x555555);
        scene.add(arrow);
        arrowForces.push(arrow);
        //add trajectories. See <http://stackoverflow.com/questions/31399856/drawing-a-line-with-three-js-dynamically>
        if (if_showTrajectory) {
          var thisGeometry = new THREE.BufferGeometry();
          trajectoryGeometries.push(thisGeometry);
          // attributes
          var point = new Float32Array(maxTrajectoryLength * 3); // 3 vertices per point
          thisGeometry.addAttribute('position', new THREE.BufferAttribute(point, 3));
          for (var i = 0; i < maxTrajectoryLength; i++) thisGeometry.attributes.position.setXYZ(i, thisPosition.x, thisPosition.y, thisPosition.z);
          var thisTrajectoryColor = thisColor.clone();
          thisTrajectoryColor.offsetHSL(0, -0.5, 0.2);
          thisTrajectoryMaterial = new THREE.LineBasicMaterial({
            color: thisTrajectoryColor,
            linewidth: .5
          });
          var thisTrajectory = new THREE.Line(thisGeometry, thisTrajectoryMaterial);
          trajectoryLines.push(thisTrajectory);
          scene.add(thisTrajectory);
        }
      }
      // Particles are just individual vertices in a geometry
      // Create the geometry that will hold all of the vertices
      particles = new THREE.Geometry();
      texture = new THREE.Texture(generateTexture());
      texture.needsUpdate = true; // important
      particleMaterial = new THREE.PointsMaterial({ //http://jsfiddle.net/7yDGy/1/
        map: texture,
        blending: THREE.NormalBlending, // required
        depthTest: false, // required
        transparent: true,
        opacity: 0.9,
        size: .3,
        vertexColors: THREE.VertexColors
      });
	    function loadState() {
	    	console.log('Loading particleColors...');
			particleColors = localStorage.getItem('particleColors');
			if (particleColors == null) {
				particleColors = [];
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading particlePositions...');
			particlePositions = localStorage.getItem('particlePositions');
			if (particlePositions == null) {
				particlePositions = [];
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading particleForces...');
			particleForces = localStorage.getItem('particleForces');
			if (particleForces == null) {
				particleForces = [];
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading particleVelocities...');
			particleVelocities = localStorage.getItem('particleVelocities');
			if (particleVelocities == null) {
				particleVelocities = [];
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading particleMasses...');
			particleMasses = localStorage.getItem('particleMasses');
			if (particleMasses == null) {
				particleMasses = [];
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading particleCharges...');
			particleCharges = localStorage.getItem('particleCharges');
			if (particleCharges == null) {
				particleCharges = [];
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading time...');
			time = localStorage.getItem('time');
			if (time == null) {
				time = 0;
				console.log('Failed.');
				return false;
			};

	    	console.log('Loading lastSnapshotTime...');
			lastSnapshotTime = localStorage.getItem('lastSnapshotTime');
			if (lastSnapshotTime == null) {
				lastSnapshotTime = 0;
				console.log('Failed.');
				return false;
			};
			console.log('Successfully loaded all variables.');
			return true;
	    };
      // Create the vertices and add them to the particles geometry
      if (loadState()) {
      	console.log('State from previous session loaded.');
      	//TODO: initialize the particleSystem with the info stored from localStorage.
      } else {
      	  console.log('Creating new universe.');
	      //create a sun:
	      if (if_makeSun) addParticle(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, sunMass, 0); //always make the sun the first particle, please.
	      for (var i = particlePositions.length; i < particleCount; i++) {
	        if (if_makeSun) {
	          var this_x = _.random(-spaceBoundaryX, spaceBoundaryX, true);
	          var this_y = 0;
	          var this_z = _.random(-spaceBoundaryZ, spaceBoundaryZ, true);
	          var this_r = Math.sqrt(this_x * this_x + this_y * this_y + this_z * this_z);
	          var this_vx = 0;
	          var this_vy = Math.sqrt(G * particleMasses[0] / this_r);
	          var this_vz = 0;
	          if (i % 2 == 0) this_vy *= -1;
	        } else {
	          var this_x = _.random(-spaceBoundaryX, spaceBoundaryX, true);
	          var this_y = _.random(-spaceBoundaryY, spaceBoundaryY, true);
	          var this_z = _.random(-spaceBoundaryZ, spaceBoundaryZ, true);
	          var this_r = Math.sqrt(this_x * this_x + this_y * this_y + this_z * this_z);
	          var this_vx = 0;
	          var this_vy = 0;
	          var this_vz = 0;
	        };
	        addParticle(Math.random(), 1.0, 0.5,
	          this_x, this_y, this_z,
	          this_vx, this_vy, this_vz,
	          0, 0, 0,
	          _.random(16, 20, true),
	          _.sample(availableCharges));
	      };
  	  };
      particles.colors = particleColors;
      // Create the material that will be used to render each vertex of the geometry
      // Create the particle system
      particleSystem = new THREE.Points(particles, particleMaterial);
      return particleSystem;
    }

    function init() {
      //initialize the scene
      scene = new THREE.Scene();
      //    configure the scene:
      if (if_useFog) scene.fog = new THREE.Fog(0xffffff, 0, 20);
      //    define objects:
      if (if_showUniverseBoundary) drawBox();
      scene.add(createParticleSystem());
      //initialize the camera
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000000);
      camera.position.set(0, 2, 10);
      scene.add(camera);
      //initialize renderer
      renderer = new THREE.WebGLRenderer({
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(4); //enhance resolution
      if (if_mobileDevice) effect = new THREE.StereoEffect(renderer);
      element = renderer.domElement;
      container = document.body; 
      container.appendChild(element);
      //activate plugins:
      controls = new THREE.OrbitControls(camera, element);//this is for non-VR devices
      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', fullscreen, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }
      window.addEventListener('deviceorientation', setOrientationControls, true);
      //add stat
      stats = new Stats();
      container.appendChild(stats.domElement);
      //add event listeners

      window.addEventListener('resize', resize, false);
      setTimeout(resize,1);

    }

    function animate() {
      time += dt;
      //for (var i in arrows) {scene.remove(arrows[i])}; //remove all existing arrows
      for (var i = 0; i < particleCount; i++) particleForces[i].set(0, 0, 0); //remove all forces first
      for (var i = 0; i < particleCount; i++)
        for (var j = i + 1; j < particleCount; j++) {
          //generate all forces:
          if (if_apply_LJpotential) {
            // Use Lennard-Jones potential
            // V = 4*epsilon*((delta/d)^12 - (delta/d)^6)
            // F = 4*epsilon*(-12/d*(delta/d)^12 + 6/d*(delta/d)^6) r/|r|
=======
>>>>>>> gh-pages

<body>
    <div class="mapscale" id="velocity">Speed</div>
    <div class="mapscale" id="force">Force</div>



    <script src="modules/jquery.min.js"></script>
    <script src="modules/three.min.js"></script>
    <script src="modules/OrbitControls.js"></script>
    <script src="modules/lodash.min.js"></script>
    <script src="modules/stats.min.js"></script>
    <script src="modules/StereoEffect.js"></script>
    <script src="modules/DeviceOrientationControls.js"></script>
    <script src="modules/dat.gui.min.js"></script>

    <script src="settings.js"></script>
    <script src="stateStorage.js"></script>
    <script src="script.js"></script>
</body>

</html>
