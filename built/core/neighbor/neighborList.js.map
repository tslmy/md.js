{"version":3,"file":"neighborList.js","sourceRoot":"","sources":["../../../src/core/neighbor/neighborList.ts"],"names":[],"mappings":"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","sourcesContent":["/** Neighbor list abstraction scaffold.\n * Current implementation delegates to naive O(N^2) but records structure for future cell lists.\n */\nimport type { SimulationState } from '../simulation/state.js'\nimport { setPairIterationImpl, PairIterationImpl } from '../forces/forceInterfaces.js'\n\nexport interface NeighborListStrategy {\n  /** Human-readable identifier. */\n  readonly name: string\n  /** Rebuild internal structures given current positions (called each step if strategy requests). */\n  rebuild(state: SimulationState, cutoff: number): void\n  /** Pair iteration implementation bound to internal structures. */\n  forEachPair: PairIterationImpl\n  /** If true engine will call rebuild every step; else caller must manage cadence. */\n  readonly rebuildEveryStep: boolean\n}\n\n/** Naive strategy passthrough – baseline correctness reference. */\nexport function createNaiveNeighborStrategy(): NeighborListStrategy {\n  return {\n    name: 'naive',\n    rebuild() {/* noop */},\n    forEachPair: (state, cutoff, handler) => {\n      // Use temporary override-free logic replicating previous naive implementation\n      const { N, positions } = state\n      const cutoff2 = cutoff * cutoff\n      for (let i = 0; i < N; i++) {\n        const i3 = 3 * i\n        const ix = positions[i3]; const iy = positions[i3 + 1]; const iz = positions[i3 + 2]\n        for (let j = i + 1; j < N; j++) {\n          const j3 = 3 * j\n          const dx = ix - positions[j3]\n          const dy = iy - positions[j3 + 1]\n          const dz = iz - positions[j3 + 2]\n          const r2 = dx * dx + dy * dy + dz * dz\n          if (r2 <= cutoff2) handler(i, j, dx, dy, dz, r2)\n        }\n      }\n    },\n    rebuildEveryStep: false\n  }\n}\n\n/** Install the pair iteration of a strategy globally for force plugins. */\nexport function activateNeighborStrategy(strategy: NeighborListStrategy): void {\n  setPairIterationImpl(strategy.forEachPair)\n}\n\n// ---------------- Cell (uniform grid) strategy (basic) ----------------\n\n/**\n * Internal structure for the uniform cell (aka \"linked‑cell\") neighbor list strategy.\n *\n * Design (current minimal version):\n *  - Space is partitioned into a cubic lattice of axis‑aligned cells of edge length ~= cutoff.\n *  - Each cell stores a singly linked list of particle indices (heads[] + next[] arrays) – a classic SoA pattern.\n *  - During pair iteration we only inspect the 27 Moore‑neighborhood (cell itself + adjacent cells),\n *    which guarantees that any pair whose separation r <= cutoff lies either in the same cell or a neighbor cell\n *    (because cell edge >= cutoff, a particle cannot \"skip\" past a neighbor cell without exceeding the distance).\n *\n * Simplifications / Assumptions (to be revisited):\n *  - We approximate the simulation box as a cube with side length 4*cutoff centered at origin (L = 2*cutoff radius each side).\n *    This keeps code independent from a formal world box for now; out‑of‑range particles are clamped into edge cells.\n *  - No periodic wrapping yet; periodic boundary support will require mapping neighbor lookups across opposite faces.\n *  - Rebuild occurs every step (rebuildEveryStep: true). Later we can support Verlet shell (buffer) to rebuild less often.\n *  - Cell size fixed = cutoff; a tuned factor (e.g. half or using skin distance) could improve balance between cell count and neighbor checks.\n *\n * Complexity:\n *  - Rebuild: O(N) to assign each particle to a cell.\n *  - Pair iteration: O(N + M) where M is number of candidate pairs in 27 neighborhoods.\n *    For roughly uniform density this trends toward linear scaling in N (contrast naive O(N^2)).\n *\n * Memory:\n *  - heads: #cells (Int32 each)\n *  - next: N (Int32 each)\n *  - We intentionally avoid per‑cell dynamic arrays to stay GC‑free.\n */\ninterface CellListData {\n  cellSize: number\n  dims: [number, number, number]\n  // head indices per cell (linked list), -1 sentinel\n  heads: Int32Array\n  // linked list next pointer per particle\n  next: Int32Array\n}\n\n/** Compute linear cell index. */\nfunction cellIndex(ix: number, iy: number, iz: number, dims: [number, number, number]): number {\n  const [nx, ny] = dims\n  return ix + nx * (iy + ny * iz)\n}\n\n/** Create cell list buffers sized for current box & cutoff. */\n/**\n * Allocate & initialize cell list buffers sized for a heuristic cubic region.\n * NOTE: The heuristic picks n = floor( (4*cutoff) / cutoff ) = ~4 cells per axis (unless cutoff tiny).\n * This is intentionally coarse; a future revision should derive from actual world box extents.\n */\nfunction createCellList(state: SimulationState, cutoff: number): CellListData {\n  const cellSize = cutoff\n  const L = cutoff * 2\n  const n = Math.max(1, Math.floor((2 * L) / cellSize))\n  const total = n * n * n\n  return { cellSize, dims: [n, n, n], heads: new Int32Array(total).fill(-1), next: new Int32Array(state.N).fill(-1) }\n}\n\n/** Rebuild particle -> cell linked lists. */\n/**\n * Rebuild stage: assigns every particle to exactly one cell by *prepending* it to that cell's linked list.\n * We clamp positions into the [0, n-1] index range per axis to keep indices valid when particles drift outside heuristic bounds.\n * This clamping induces slight over‑approximation of neighbor candidates for escaped particles but preserves correctness.\n */\nfunction rebuildCellList(state: SimulationState, cutoff: number, data: CellListData): void {\n  const { positions, N } = state\n  const { cellSize, dims, heads, next } = data\n  heads.fill(-1)\n  next.fill(-1)\n  const [nx, ny, nz] = dims // here we use all three\n  const L = cutoff * 2\n  for (let i = 0; i < N; i++) {\n    const i3 = 3 * i\n    const x = positions[i3]\n    const y = positions[i3 + 1]\n    const z = positions[i3 + 2]\n    // Map position into [0,2L) then to cell index (very approximate; assumes particles remain near origin)\n    const fx = Math.min(nx - 1, Math.max(0, Math.floor((x + L) / cellSize)))\n    const fy = Math.min(ny - 1, Math.max(0, Math.floor((y + L) / cellSize)))\n    const fz = Math.min(nz - 1, Math.max(0, Math.floor((z + L) / cellSize)))\n    const ci = cellIndex(fx, fy, fz, dims)\n    next[i] = heads[ci]\n    heads[ci] = i\n  }\n}\n\n/** Iterate pairs using 27-neighborhood. */\n/**\n * Iterate candidate pairs by scanning each cell and its 26 neighbors.\n * We enforce an ordering rule to avoid duplicates:\n *   - If neighborIdx === baseIdx we only emit (a,b) with b > a.\n *   - For distinct cells we emit all (a,b) (because each cell pair is visited exactly once in this traversal order).\n *\n * Correctness argument (no missed pairs): For any two particles p,q within distance cutoff, place them in cells Cp,Cq.\n * Because cell edge >= cutoff, either Cp == Cq or Cp and Cq share a face/edge/corner => Cq in Moore neighborhood of Cp.\n * Thus the (Cp neighborhood) scan will encounter q when processing Cp.\n */\nfunction cellForEachPair(state: SimulationState, cutoff: number, handler: (i: number, j: number, dx: number, dy: number, dz: number, r2: number) => void, data: CellListData): void {\n  const cutoff2 = cutoff * cutoff\n  const { positions } = state\n  const { heads, next, dims } = data\n  const [nx, ny, nz] = dims\n  const neighborsOf = (ix: number, iy: number, iz: number, cb: (neighborIdx: number) => void) => {\n    for (let dxCell = -1; dxCell <= 1; dxCell++) {\n      const jx = ix + dxCell; if (jx < 0 || jx >= nx) continue\n      for (let dyCell = -1; dyCell <= 1; dyCell++) {\n        const jy = iy + dyCell; if (jy < 0 || jy >= ny) continue\n        for (let dzCell = -1; dzCell <= 1; dzCell++) {\n          const jz = iz + dzCell; if (jz < 0 || jz >= nz) continue\n          cb(cellIndex(jx, jy, jz, dims))\n        }\n      }\n    }\n  }\n  const visitCellPair = (baseIdx: number, neighborIdx: number) => {\n    for (let a = heads[baseIdx]; a !== -1; a = next[a]) {\n      const a3 = 3 * a\n      const ax = positions[a3]; const ay = positions[a3 + 1]; const az = positions[a3 + 2]\n      for (let b = heads[neighborIdx]; b !== -1; b = next[b]) {\n        if (neighborIdx === baseIdx && b <= a) continue\n        const b3 = 3 * b\n        const dx = ax - positions[b3]\n        const dy = ay - positions[b3 + 1]\n        const dz = az - positions[b3 + 2]\n        const r2 = dx * dx + dy * dy + dz * dz\n        if (r2 <= cutoff2) handler(a, b, dx, dy, dz, r2)\n      }\n    }\n  }\n  for (let ix = 0; ix < nx; ix++) for (let iy = 0; iy < ny; iy++) for (let iz = 0; iz < nz; iz++) {\n    const baseIdx = cellIndex(ix, iy, iz, dims)\n    neighborsOf(ix, iy, iz, neighborIdx => visitCellPair(baseIdx, neighborIdx))\n  }\n}\n\n/**\n * Factory for the cell neighbor list strategy.\n * Exposed surface mirrors the naive variant so the engine can switch transparently.\n * Future improvements roadmap:\n *  - Periodic boundary wrapping (map neighbor lookups across boundaries)\n *  - Adaptive / user‑provided world box & dynamic reboxing\n *  - Verlet shell (skin) distance to rebuild less frequently (track max displacement)\n *  - SIMD / WASM batch distance checks\n */\nexport function createCellNeighborStrategy(): NeighborListStrategy {\n  let data: CellListData | null = null\n  return {\n    name: 'cell',\n    rebuild(state, cutoff) {\n      if (!data || state.N !== data.next.length) data = createCellList(state, cutoff)\n      rebuildCellList(state, cutoff, data)\n    },\n    forEachPair: (state, cutoff, handler) => {\n      if (!data) {\n        data = createCellList(state, cutoff)\n        rebuildCellList(state, cutoff, data)\n      }\n      cellForEachPair(state, cutoff, handler, data)\n    },\n    rebuildEveryStep: true\n  }\n}\n"]}
