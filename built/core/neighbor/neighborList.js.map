{"version":3,"file":"neighborList.js","sourceRoot":"","sources":["../../../src/core/neighbor/neighborList.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,oBAAoB,EAAqB,MAAM,8BAA8B,CAAA;AAatF,mEAAmE;AACnE,MAAM,UAAU,2BAA2B;IACzC,OAAO;QACL,IAAI,EAAE,OAAO;QACb,OAAO,KAAc,CAAC;QACtB,WAAW,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE;YACtC,8EAA8E;YAC9E,MAAM,EAAE,CAAC,EAAE,SAAS,EAAE,GAAG,KAAK,CAAA;YAC9B,MAAM,OAAO,GAAG,MAAM,GAAG,MAAM,CAAA;YAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC3B,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,CAAA;gBAChB,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;gBAAC,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;gBAAC,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;gBACpF,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC/B,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,CAAA;oBAChB,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAA;oBAC7B,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;oBACjC,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;oBACjC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAA;oBACtC,IAAI,EAAE,IAAI,OAAO;wBAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;gBAClD,CAAC;YACH,CAAC;QACH,CAAC;QACD,gBAAgB,EAAE,KAAK;KACxB,CAAA;AACH,CAAC;AAED,2EAA2E;AAC3E,MAAM,UAAU,wBAAwB,CAAC,QAA8B;IACrE,oBAAoB,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAA;AAC5C,CAAC","sourcesContent":["/** Neighbor list abstraction scaffold.\n * Current implementation delegates to naive O(N^2) but records structure for future cell lists.\n */\nimport type { SimulationState } from '../simulation/state.js'\nimport { setPairIterationImpl, PairIterationImpl } from '../forces/forceInterfaces.js'\n\nexport interface NeighborListStrategy {\n  /** Human-readable identifier. */\n  readonly name: string\n  /** Rebuild internal structures given current positions (called each step if strategy requests). */\n  rebuild(state: SimulationState, cutoff: number): void\n  /** Pair iteration implementation bound to internal structures. */\n  forEachPair: PairIterationImpl\n  /** If true engine will call rebuild every step; else caller must manage cadence. */\n  readonly rebuildEveryStep: boolean\n}\n\n/** Naive strategy passthrough â€“ baseline correctness reference. */\nexport function createNaiveNeighborStrategy(): NeighborListStrategy {\n  return {\n    name: 'naive',\n    rebuild() {/* noop */},\n    forEachPair: (state, cutoff, handler) => {\n      // Use temporary override-free logic replicating previous naive implementation\n      const { N, positions } = state\n      const cutoff2 = cutoff * cutoff\n      for (let i = 0; i < N; i++) {\n        const i3 = 3 * i\n        const ix = positions[i3]; const iy = positions[i3 + 1]; const iz = positions[i3 + 2]\n        for (let j = i + 1; j < N; j++) {\n          const j3 = 3 * j\n          const dx = ix - positions[j3]\n          const dy = iy - positions[j3 + 1]\n          const dz = iz - positions[j3 + 2]\n          const r2 = dx * dx + dy * dy + dz * dz\n          if (r2 <= cutoff2) handler(i, j, dx, dy, dz, r2)\n        }\n      }\n    },\n    rebuildEveryStep: false\n  }\n}\n\n/** Install the pair iteration of a strategy globally for force plugins. */\nexport function activateNeighborStrategy(strategy: NeighborListStrategy): void {\n  setPairIterationImpl(strategy.forEachPair)\n}\n"]}