{"version":3,"file":"forceInterfaces.js","sourceRoot":"","sources":["../../../src/core/forces/forceInterfaces.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmB,MAAM,EAAE,MAAM,wBAAwB,CAAA;AAoChE,iFAAiF;AACjF,IAAI,QAAQ,GAAsB,SAAS,KAAK,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO;IACrE,MAAM,EAAE,CAAC,EAAE,SAAS,EAAE,GAAG,KAAK,CAAA;IAC9B,MAAM,OAAO,GAAG,MAAM,GAAG,MAAM,CAAA;IAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;QACpB,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;QAAC,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QAAC,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;QACpF,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/B,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;YACpB,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAA;YAC7B,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;YACjC,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;YACjC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAA;YACtC,IAAI,EAAE,IAAI,OAAO;gBAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;QAClD,CAAC;IACH,CAAC;AACH,CAAC,CAAA;AAED,qEAAqE;AACrE,MAAM,UAAU,oBAAoB,CAAC,EAAqB,IAAU,QAAQ,GAAG,EAAE,CAAA,CAAC,CAAC;AAEnF,yDAAyD;AACzD,MAAM,UAAU,WAAW,CAAC,KAAsB,EAAE,MAAc,EAAE,OAAoB,IAAU,QAAQ,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA,CAAC,CAAC","sourcesContent":["import { SimulationState, index3 } from '../simulation/state.js'\n\n/**\n * A ForceField encapsulates one physical interaction rule (e.g. gravity, electrostatics, Lennard-Jones).\n * Implementation rule of thumb for contributors without physics background:\n *  - Read pairwise loops as: for every unique unordered particle pair (i,j) within a certain distance (cutoff) compute a push/pull.\n *  - Add that push to one particle and the opposite to the other (Newton's third law ensures momentum conservation).\n *  - The magnitude formulas (inside specific forces) translate domain constants into numeric coefficients.\n */\n\nexport interface ForceField {\n  /** Unique short identifier for diagnostics */\n  readonly name: string\n  /** Accumulate force contributions into state.forces (must only add; never reset arrays here). */\n  apply(state: SimulationState, ctx: ForceContext): void\n  /** Optional: return total potential energy contribution for current state (pairwise sum). */\n  potential?(state: SimulationState, ctx: ForceContext): number\n}\n\nexport interface ForceContext {\n  /** Maximum interaction distance (optimization to skip weak far pairs). */\n  cutoff: number\n  /** Optional feature flags to gate specialized logic (reserved for future extensions). */\n  flags?: Record<string, boolean>\n  /** Optional constants bag for experimental force tuning without changing signatures. */\n  constants?: Record<string, number>\n}\n\nexport type PairHandler = (i: number, j: number, dx: number, dy: number, dz: number, r2: number) => void\n\n/**\n * Pair iteration implementation signature.\n * Replaces direct O(N^2) loops so we can later introduce spatial partition acceleration structures.\n */\nexport type PairIterationImpl = (state: SimulationState, cutoff: number, handler: PairHandler) => void\n\n// Default naive implementation (module-local so tests can still wrap via setter)\nlet pairImpl: PairIterationImpl = function naive(state, cutoff, handler) {\n  const { N, positions } = state\n  const cutoff2 = cutoff * cutoff\n  for (let i = 0; i < N; i++) {\n    const i3 = index3(i)\n    const ix = positions[i3]; const iy = positions[i3 + 1]; const iz = positions[i3 + 2]\n    for (let j = i + 1; j < N; j++) {\n      const j3 = index3(j)\n      const dx = ix - positions[j3]\n      const dy = iy - positions[j3 + 1]\n      const dz = iz - positions[j3 + 2]\n      const r2 = dx * dx + dy * dy + dz * dz\n      if (r2 <= cutoff2) handler(i, j, dx, dy, dz, r2)\n    }\n  }\n}\n\n/** Set the global pair iteration implementation (engine / tests). */\nexport function setPairIterationImpl(fn: PairIterationImpl): void { pairImpl = fn }\n\n/** Execute the current pair iteration implementation. */\nexport function forEachPair(state: SimulationState, cutoff: number, handler: PairHandler): void { pairImpl(state, cutoff, handler) }\n"]}