{"version":3,"file":"forceInterfaces.js","sourceRoot":"","sources":["../../../src/core/forces/forceInterfaces.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmB,MAAM,EAAE,MAAM,wBAAwB,CAAA;AA8BhE;;;;GAIG;AACH,MAAM,UAAU,WAAW,CAAC,KAAsB,EAAE,MAAc,EAAE,OAAoB;IACtF,MAAM,EAAE,CAAC,EAAE,SAAS,EAAE,GAAG,KAAK,CAAA;IAC9B,MAAM,OAAO,GAAG,MAAM,GAAG,MAAM,CAAA;IAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;QACpB,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAA;QACxB,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;QAC5B,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/B,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;YACpB,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAA;YAC7B,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;YACjC,MAAM,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;YACjC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAA;YACtC,IAAI,EAAE,IAAI,OAAO;gBAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;QAClD,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["import { SimulationState, index3 } from '../simulation/state.js'\n\n/**\n * A ForceField encapsulates one physical interaction rule (e.g. gravity, electrostatics, Lennard-Jones).\n * Implementation rule of thumb for contributors without physics background:\n *  - Read pairwise loops as: for every unique unordered particle pair (i,j) within a certain distance (cutoff) compute a push/pull.\n *  - Add that push to one particle and the opposite to the other (Newton's third law ensures momentum conservation).\n *  - The magnitude formulas (inside specific forces) translate domain constants into numeric coefficients.\n */\n\nexport interface ForceField {\n  /** Unique short identifier for diagnostics */\n  readonly name: string\n  /** Accumulate force contributions into state.forces (must only add; never reset arrays here). */\n  apply(state: SimulationState, ctx: ForceContext): void\n  /** Optional: return total potential energy contribution for current state (pairwise sum). */\n  potential?(state: SimulationState, ctx: ForceContext): number\n}\n\nexport interface ForceContext {\n  /** Maximum interaction distance (optimization to skip weak far pairs). */\n  cutoff: number\n  /** Optional feature flags to gate specialized logic (reserved for future extensions). */\n  flags?: Record<string, boolean>\n  /** Optional constants bag for experimental force tuning without changing signatures. */\n  constants?: Record<string, number>\n}\n\nexport type PairHandler = (i: number, j: number, dx: number, dy: number, dz: number, r2: number) => void\n\n/**\n * Naive O(N^2) pair iterator with distance cutoff.\n * For each i<j pair inside cutoff^2 calls the handler once.\n * Future optimization path: replace with cell / neighbor list to cut complexity toward O(N).\n */\nexport function forEachPair(state: SimulationState, cutoff: number, handler: PairHandler): void {\n  const { N, positions } = state\n  const cutoff2 = cutoff * cutoff\n  for (let i = 0; i < N; i++) {\n    const i3 = index3(i)\n    const ix = positions[i3]\n    const iy = positions[i3 + 1]\n    const iz = positions[i3 + 2]\n    for (let j = i + 1; j < N; j++) {\n      const j3 = index3(j)\n      const dx = ix - positions[j3]\n      const dy = iy - positions[j3 + 1]\n      const dz = iz - positions[j3 + 2]\n      const r2 = dx * dx + dy * dy + dz * dz\n      if (r2 <= cutoff2) handler(i, j, dx, dy, dz, r2)\n    }\n  }\n}\n"]}
