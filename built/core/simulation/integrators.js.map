{"version":3,"file":"integrators.js","sourceRoot":"","sources":["../../../src/core/simulation/integrators.ts"],"names":[],"mappings":"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","sourcesContent":["import { SimulationState, index3 } from './state.js'\n\n/**\n * Integrators advance the simulation state in time using current forces.\n *\n * Background (high level, non-physics wording):\n *  - Particles have positions (where they are) and velocities (how fast & which direction they move).\n *  - Forces act like pushes / pulls. Given a force and a particle's mass we derive acceleration (push strength per mass).\n *  - An integrator uses the forces to update velocities & positions over a small timestep dt.\n *  - Different integrators trade implementation simplicity vs. numerical stability (how well they conserve energy over time).\n */\n\nexport interface Integrator {\n  /**\n   * Perform one timestep update.\n   * @param state Mutable arrays holding positions, velocities and forces.\n   * @param dt   Size of the time increment.\n   * @param recomputeForces Callback the integrator can invoke (0 or more times) to rebuild forces for the current positions.\n   */\n  step(state: SimulationState, dt: number, recomputeForces: () => void): void\n}\n\n/**\n * Explicit Euler integrator.\n * Simple: updates velocity using current force, then position using updated velocity.\n * Pros: minimal code.\n * Cons: poor energy conservation & stability; accumulates drift quickly.\n * We keep this mostly for quick A/B testing and pedagogical clarity.\n */\nexport const EulerIntegrator: Integrator = {\n  step(state, dt) {\n    const { N, positions, velocities, forces, masses } = state\n    for (let i = 0; i < N; i++) {\n      const i3 = index3(i)\n      const invM = 1 / (masses[i] || 1)\n      velocities[i3] += forces[i3] * invM * dt\n      velocities[i3 + 1] += forces[i3 + 1] * invM * dt\n      velocities[i3 + 2] += forces[i3 + 2] * invM * dt\n      positions[i3] += velocities[i3] * dt\n      positions[i3 + 1] += velocities[i3 + 1] * dt\n      positions[i3 + 2] += velocities[i3 + 2] * dt\n    }\n    state.time += dt\n  }\n}\n\n/**\n * Velocity Verlet integrator (a symplectic method) â€“ preferred for MD-like systems.\n * Conceptual steps:\n * 1. Use current acceleration to predict new position (full dt) and advance velocity half a step.\n * 2. Recompute forces (thus new acceleration) at the new position.\n * 3. Finish the velocity update with the new acceleration half step.\n * Why better than Euler: time-reversible & symplectic -> significantly improved conservation of invariants (like total energy) for conservative forces, so systems do not \"heat up\" or \"cool down\" artificially as fast.\n * Complexity note: requires a second force computation per step (already encapsulated via callback here).\n */\nexport const VelocityVerlet: Integrator = {\n  step(state, dt, recomputeForces) {\n    const { N, positions, velocities, forces, masses } = state\n    const dt2 = dt * dt\n    // Allocate scratch for initial accelerations (reuse per step to keep simple)\n    const a0 = new Float32Array(N * 3)\n    // 1. Use current forces to advance positions and half-step velocities\n    for (let i = 0; i < N; i++) {\n      const i3 = index3(i)\n      const invM = 1 / (masses[i] || 1)\n      const ax = forces[i3] * invM\n      const ay = forces[i3 + 1] * invM\n      const az = forces[i3 + 2] * invM\n      a0[i3] = ax; a0[i3 + 1] = ay; a0[i3 + 2] = az\n      // position(t+dt)\n      positions[i3] += velocities[i3] * dt + 0.5 * ax * dt2\n      positions[i3 + 1] += velocities[i3 + 1] * dt + 0.5 * ay * dt2\n      positions[i3 + 2] += velocities[i3 + 2] * dt + 0.5 * az * dt2\n      // v half-step\n      velocities[i3] += 0.5 * ax * dt\n      velocities[i3 + 1] += 0.5 * ay * dt\n      velocities[i3 + 2] += 0.5 * az * dt\n    }\n    // 2. Recompute forces with updated positions\n    recomputeForces()\n    // 3. Complete velocity update with new accelerations\n    for (let i = 0; i < N; i++) {\n      const i3 = index3(i)\n      const invM = 1 / (masses[i] || 1)\n      const axNew = forces[i3] * invM\n      const ayNew = forces[i3 + 1] * invM\n      const azNew = forces[i3 + 2] * invM\n      velocities[i3] += 0.5 * axNew * dt\n      velocities[i3 + 1] += 0.5 * ayNew * dt\n      velocities[i3 + 2] += 0.5 * azNew * dt\n    }\n    state.time += dt\n  }\n}\n"]}
