{"version":3,"file":"Simulation.js","sourceRoot":"","sources":["../../../src/core/simulation/Simulation.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmB,UAAU,EAAE,MAAM,YAAY,CAAA;AASxD,MAAM,OAAO,UAAU;IACrB,YACkB,KAAsB,EACrB,UAAsB,EACxB,MAAoB,EAClB,MAAwB;QAHzB,UAAK,GAAL,KAAK,CAAiB;QACrB,eAAU,GAAV,UAAU,CAAY;QACxB,WAAM,GAAN,MAAM,CAAc;QAClB,WAAM,GAAN,MAAM,CAAkB;IACxC,CAAC;IAEJ,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAA;QAClC,MAAM,eAAe,GAAG,GAAG,EAAE;YAC3B,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YACtB,MAAM,GAAG,GAAiB,EAAE,MAAM,EAAE,CAAA;YACpC,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,MAAM;gBAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAA;QACvD,CAAC,CAAA;QACD,8FAA8F;QAC9F,eAAe,EAAE,CAAA;QACjB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,eAAe,CAAC,CAAA;IACvD,CAAC;IAED,QAAQ,CAAC,CAAa,IAAU,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA,CAAC,CAAC;IAErD,SAAS,KAAmB,OAAO,IAAI,CAAC,MAAM,CAAA,CAAC,CAAC;CACjD","sourcesContent":["import { SimulationState, zeroForces } from './state.js'\nimport { Integrator } from './integrators.js'\nimport { ForceField, ForceContext } from '../forces/forceInterfaces.js'\n\nexport interface SimulationConfig {\n  dt: number\n  cutoff: number\n}\n\nexport class Simulation {\n  constructor(\n    public readonly state: SimulationState,\n    private readonly integrator: Integrator,\n  private readonly forces: ForceField[],\n    private readonly config: SimulationConfig\n  ) {}\n\n  step(): void {\n    const { dt, cutoff } = this.config\n    const recomputeForces = () => {\n      zeroForces(this.state)\n      const ctx: ForceContext = { cutoff }\n      for (const f of this.forces) f.apply(this.state, ctx)\n    }\n    // Initial force computation (Euler requires only once; Verlet will call back for second pass)\n    recomputeForces()\n    this.integrator.step(this.state, dt, recomputeForces)\n  }\n\n  addForce(f: ForceField): void { this.forces.push(f) }\n\n  getForces(): ForceField[] { return this.forces }\n}\n"]}
