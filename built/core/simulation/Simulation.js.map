{"version":3,"file":"Simulation.js","sourceRoot":"","sources":["../../../src/core/simulation/Simulation.ts"],"names":[],"mappings":"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","sourcesContent":["import { SimulationState, zeroForces } from './state.js'\nimport { Integrator } from './integrators.js'\nimport { ForceField, ForceContext } from '../forces/forceInterfaces.js'\n\nexport interface SimulationConfig {\n  dt: number\n  cutoff: number\n}\n\nexport class Simulation {\n  /** Per-force decomposition of the instantaneous force vector (flattened xyz per particle). */\n  private perForce!: Float32Array[]\n  /** Scratch buffer used while isolating each force contribution without editing individual force plugins. */\n  private baseForces!: Float32Array\n  constructor(\n    public readonly state: SimulationState,\n    private readonly integrator: Integrator,\n  private readonly forces: ForceField[],\n    private readonly config: SimulationConfig\n  ) {}\n\n  private ensureBuffers(): void {\n    if (!this.perForce || this.perForce.length !== this.forces.length) {\n      this.perForce = this.forces.map(() => new Float32Array(this.state.forces.length))\n    }\n    if (!this.baseForces || this.baseForces.length !== this.state.forces.length) {\n      this.baseForces = new Float32Array(this.state.forces.length)\n    }\n  }\n\n  private computeForcesDetailed(): void {\n    const { cutoff } = this.config\n    this.ensureBuffers()\n    zeroForces(this.state)\n    // Clear per-force arrays\n    for (const arr of this.perForce) arr.fill(0)\n    const ctx: ForceContext = { cutoff }\n    const { forces } = this.state\n    for (let k = 0; k < this.forces.length; k++) {\n      // Snapshot current accumulated forces\n      this.baseForces.set(forces)\n      this.forces[k].apply(this.state, ctx)\n      const out = this.perForce[k]\n      // delta = new - base\n      for (let i = 0; i < forces.length; i++) out[i] = forces[i] - this.baseForces[i]\n    }\n  }\n\n  step(): void {\n  const { dt } = this.config\n  const recomputeForces = () => this.computeForcesDetailed()\n    // Initial force computation (Euler requires only once; Verlet will call back for second pass)\n    recomputeForces()\n    this.integrator.step(this.state, dt, recomputeForces)\n  }\n\n  addForce(f: ForceField): void { this.forces.push(f) }\n\n  getForces(): ForceField[] { return this.forces }\n\n  /** Return mapping of force name -> per-particle force contribution array (length 3N). */\n  getPerForceContributions(): Record<string, Float32Array> {\n    this.ensureBuffers()\n    const map: Record<string, Float32Array> = {}\n    for (let i = 0; i < this.forces.length; i++) map[this.forces[i].name] = this.perForce[i]\n    return map\n  }\n}\n"]}
