{"version":3,"file":"diagnostics.js","sourceRoot":"","sources":["../../../src/core/simulation/diagnostics.ts"],"names":[],"mappings":"AAgCA;;;GAGG;AACH,SAAS,wBAAwB,CAAC,KAAsB;IACtD,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,GAAG,KAAK,CAAA;IAC/C,IAAI,EAAE,GAAG,CAAC,CAAA;IACV,IAAI,QAAQ,GAAG,CAAC,CAAA;IAChB,IAAI,QAAQ,GAAG,CAAC,CAAA;IAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,CAAA;QAChB,MAAM,EAAE,GAAG,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,GAAG,UAAU,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,GAAG,UAAU,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;QAC3E,MAAM,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAA;QAC1C,EAAE,IAAI,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,MAAM,CAAA;QACrC,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC/B,IAAI,KAAK,GAAG,QAAQ;YAAE,QAAQ,GAAG,KAAK,CAAA;QACtC,MAAM,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;QAC/D,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;QACnC,IAAI,IAAI,GAAG,QAAQ;YAAE,QAAQ,GAAG,IAAI,CAAA;IACtC,CAAC;IACD,OAAO,EAAE,OAAO,EAAE,EAAE,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAA;AACzD,CAAC;AAED;;;;;GAKG;AACH,SAAS,gBAAgB,CAAC,KAAsB,EAAE,MAAoB,EAAE,OAAe;IACrF,IAAI,GAAG,GAAG,CAAC,CAAA;IACX,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE,CAAC;QACvB,mEAAmE;QACnE,IAAI,CAAC,CAAC,SAAS;YAAE,GAAG,IAAI,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAAA;IACjE,CAAC;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAAsB,EAAE,MAAoB,EAAE,MAAyB;IACxG,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAA;IAC1E,MAAM,SAAS,GAAG,gBAAgB,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAA;IAChE,MAAM,WAAW,GAAG,OAAO,GAAG,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA,CAAC,0BAA0B;IAC1F,MAAM,KAAK,GAAG,OAAO,GAAG,SAAS,CAAA;IACjC,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAA;AAC5F,CAAC","sourcesContent":["import { SimulationState } from './state.js'\nimport { ForceField } from '../forces/forceInterfaces.js'\n\n/**\n * Snapshot of high‑level physical metrics for a simulation state.\n * All values are derived from the SoA buffers; no side effects.\n *  - kinetic: 1/2 Σ m v^2\n *  - potential: sum over enabled force field potentials (approximate; recomputed fresh each call)\n *  - total: kinetic + potential\n *  - temperature: derived from equipartition KE = (3N-3)/2 kB T (subtracting 3 for momentum DOF)\n *  - maxSpeed / maxForceMag: per-particle extrema (useful for UI scaling & stability diagnostics)\n */\nexport interface Diagnostics {\n  /** Simulation time (same units as dt accumulation). */\n  time: number\n  /** Total kinetic energy. */\n  kinetic: number\n  /** Total potential energy (sum of active force field contributions). */\n  potential: number\n  /** kinetic + potential */\n  total: number\n  /** Instantaneous temperature estimate. */\n  temperature: number\n  /** Maximum particle speed (|v|). */\n  maxSpeed: number\n  /** Maximum force magnitude (|F|). */\n  maxForceMag: number\n}\n\n/** Parameters needed for diagnostics derivations. */\ninterface DiagnosticsParams { cutoff: number; kB: number }\n\n/**\n * Compute kinetic energy and per-particle extrema in a single pass.\n * Returns totals to avoid repeated iteration over N.\n */\nfunction computeKineticAndExtrema(state: SimulationState): { kinetic: number; maxSpeed: number; maxForceMag: number } {\n  const { velocities, forces, masses, N } = state\n  let ke = 0\n  let maxSpeed = 0\n  let maxForce = 0\n  for (let i = 0; i < N; i++) {\n    const i3 = 3 * i\n    const vx = velocities[i3], vy = velocities[i3 + 1], vz = velocities[i3 + 2]\n    const speed2 = vx * vx + vy * vy + vz * vz\n    ke += 0.5 * (masses[i] || 1) * speed2\n    const speed = Math.sqrt(speed2)\n    if (speed > maxSpeed) maxSpeed = speed\n    const fx = forces[i3], fy = forces[i3 + 1], fz = forces[i3 + 2]\n    const fmag = Math.hypot(fx, fy, fz)\n    if (fmag > maxForce) maxForce = fmag\n  }\n  return { kinetic: ke, maxSpeed, maxForceMag: maxForce }\n}\n\n/**\n * Recompute total potential energy for currently enabled force fields using\n * the same O(N^2) pair iterator with cutoff as force accumulation.\n * NOTE: This duplicates pair iteration per force and is intentionally simple\n * for an initial diagnostics step (can be optimized by sharing pair loops later).\n */\nfunction computePotential(state: SimulationState, forces: ForceField[], _cutoff: number): number {\n  let pot = 0\n  for (const f of forces) {\n    // ForceField interface marks potential as optional; skip if absent\n    if (f.potential) pot += f.potential(state, { cutoff: _cutoff })\n  }\n  return pot\n}\n\n/**\n * Produce a Diagnostics snapshot for the given state & active force fields.\n * Pure function: does not mutate state.\n */\nexport function computeDiagnostics(state: SimulationState, forces: ForceField[], params: DiagnosticsParams): Diagnostics {\n  const { kinetic, maxSpeed, maxForceMag } = computeKineticAndExtrema(state)\n  const potential = computePotential(state, forces, params.cutoff)\n  const temperature = kinetic * 2 / params.kB / (3 * state.N - 3) // from KE = (3N-3)/2 kB T\n  const total = kinetic + potential\n  return { time: state.time, kinetic, potential, total, temperature, maxSpeed, maxForceMag }\n}\n"]}